# React 19 Project Structure Framework
## Team Collaboration & Architecture Guide

---

## Overview
This framework presents three proven folder structures designed for medium to large teams working with React 19 projects, plus comprehensive guidance on cross-cutting concerns, asset management, and routing architecture. Each approach has distinct advantages depending on your team's size, product complexity, and development workflow.

---

## Option 1: Feature-Based Structure (Domain-Driven)
### Philosophy
Organize code by business features/domains rather than technical layers. Each feature contains all its related code (components, hooks, utils, types).

### Structure
```
src/
├── features/
│   ├── authentication/
│   │   ├── components/
│   │   │   ├── LoginForm.tsx
│   │   │   ├── RegisterForm.tsx
│   │   │   └── PasswordReset.tsx
│   │   ├── hooks/
│   │   │   ├── useAuth.ts
│   │   │   └── useSession.ts
│   │   ├── services/
│   │   │   └── authService.ts
│   │   ├── types/
│   │   │   └── auth.types.ts
│   │   ├── utils/
│   │   │   └── tokenManager.ts
│   │   ├── constants/
│   │   │   └── authConstants.ts
│   │   └── index.ts
│   │
│   ├── user-profile/
│   │   ├── components/
│   │   ├── hooks/
│   │   ├── services/
│   │   └── index.ts
│   │
│   ├── dashboard/
│   │   ├── components/
│   │   ├── hooks/
│   │   └── index.ts
│   │
│   └── notifications/
│       ├── components/
│       ├── hooks/
│       └── index.ts
│
├── shared/
│   ├── components/
│   │   ├── ui/
│   │   │   ├── Button/
│   │   │   ├── Input/
│   │   │   ├── Modal/
│   │   │   └── Card/
│   │   └── layout/
│   │       ├── Header/
│   │       ├── Footer/
│   │       └── Sidebar/
│   ├── hooks/
│   │   ├── useDebounce.ts
│   │   ├── useLocalStorage.ts
│   │   └── useMediaQuery.ts
│   ├── utils/
│   │   ├── formatters.ts
│   │   ├── validators.ts
│   │   └── helpers.ts
│   ├── types/
│   │   └── common.types.ts
│   └── constants/
│       └── config.ts
│
├── core/
│   ├── api/
│   │   ├── client.ts
│   │   └── interceptors.ts
│   ├── router/
│   │   ├── AppRouter.tsx
│   │   └── routes.config.ts
│   ├── store/
│   │   ├── index.ts
│   │   └── rootReducer.ts
│   └── providers/
│       ├── AppProviders.tsx
│       └── ThemeProvider.tsx
│
├── assets/
│   ├── images/
│   ├── fonts/
│   └── styles/
│       └── global.css
│
├── lib/
│   └── (third-party integrations)
│
├── App.tsx
└── main.tsx
```

### Advantages
- **High Cohesion**: Related code stays together, making features self-contained
- **Parallel Development**: Teams can work on different features independently with minimal conflicts
- **Easy Navigation**: Developers know exactly where feature-specific code lives
- **Scalability**: Adding new features doesn't complicate existing structure
- **Clear Ownership**: Features can be assigned to specific team members/squads
- **Easier Testing**: Test files stay close to implementation

### Disadvantages
- **Potential Duplication**: Similar logic might be duplicated across features initially
- **Refactoring Overhead**: Moving code to `shared/` requires discipline
- **Learning Curve**: New developers need to understand feature boundaries

### Best For
- Product-focused teams with clear feature domains
- Teams using squad/pod models where groups own specific features
- Applications with distinct, loosely-coupled business domains
- Microservices-style frontend architectures

### React 19 Considerations
- Use React 19's improved `use` hook for feature-specific data fetching
- Leverage Server Components for feature-level server-side logic
- Implement Actions within feature boundaries for mutations

---

## Option 2: Layer-Based Structure (Traditional MVC-Style)
### Philosophy
Separate code by technical responsibility (components, services, state, etc.). All similar types of code grouped together regardless of feature.

### Structure
```
src/
├── components/
│   ├── auth/
│   │   ├── LoginForm/
│   │   │   ├── LoginForm.tsx
│   │   │   ├── LoginForm.test.tsx
│   │   │   ├── LoginForm.module.css
│   │   │   └── index.ts
│   │   ├── RegisterForm/
│   │   └── PasswordReset/
│   │
│   ├── dashboard/
│   │   ├── DashboardWidget/
│   │   ├── StatsCard/
│   │   └── ActivityFeed/
│   │
│   ├── profile/
│   │   ├── ProfileHeader/
│   │   ├── ProfileSettings/
│   │   └── AvatarUpload/
│   │
│   ├── common/
│   │   ├── Button/
│   │   ├── Input/
│   │   ├── Modal/
│   │   └── Card/
│   │
│   └── layout/
│       ├── Header/
│       ├── Footer/
│       ├── Sidebar/
│       └── MainLayout/
│
├── hooks/
│   ├── auth/
│   │   ├── useAuth.ts
│   │   ├── useSession.ts
│   │   └── usePermissions.ts
│   ├── data/
│   │   ├── useUsers.ts
│   │   ├── useProjects.ts
│   │   └── useNotifications.ts
│   ├── common/
│   │   ├── useDebounce.ts
│   │   ├── useLocalStorage.ts
│   │   └── useMediaQuery.ts
│   └── index.ts
│
├── services/
│   ├── api/
│   │   ├── authApi.ts
│   │   ├── userApi.ts
│   │   ├── projectApi.ts
│   │   └── notificationApi.ts
│   ├── storage/
│   │   └── localStorage.ts
│   ├── analytics/
│   │   └── tracker.ts
│   └── index.ts
│
├── store/
│   ├── slices/
│   │   ├── authSlice.ts
│   │   ├── userSlice.ts
│   │   ├── uiSlice.ts
│   │   └── notificationSlice.ts
│   ├── selectors/
│   ├── middleware/
│   └── index.ts
│
├── types/
│   ├── auth.types.ts
│   ├── user.types.ts
│   ├── project.types.ts
│   ├── api.types.ts
│   └── common.types.ts
│
├── utils/
│   ├── formatters/
│   │   ├── date.ts
│   │   ├── currency.ts
│   │   └── text.ts
│   ├── validators/
│   │   ├── forms.ts
│   │   └── inputs.ts
│   ├── helpers/
│   │   └── array.ts
│   └── index.ts
│
├── constants/
│   ├── routes.ts
│   ├── api.ts
│   ├── config.ts
│   └── messages.ts
│
├── pages/
│   ├── LoginPage.tsx
│   ├── DashboardPage.tsx
│   ├── ProfilePage.tsx
│   └── NotFoundPage.tsx
│
├── router/
│   ├── AppRouter.tsx
│   ├── PrivateRoute.tsx
│   └── routes.config.ts
│
├── styles/
│   ├── variables.css
│   ├── mixins.css
│   └── global.css
│
├── assets/
│   ├── images/
│   ├── icons/
│   └── fonts/
│
├── App.tsx
└── main.tsx
```

### Advantages
- **Familiarity**: Most developers understand this traditional pattern
- **Clear Separation**: Easy to see all components, services, hooks at a glance
- **Code Reuse**: Easier to identify and prevent duplication
- **Specialized Teams**: Frontend specialists, API developers can focus on their layers
- **Simple Navigation**: Technical role determines folder location

### Disadvantages
- **Cross-Cutting Changes**: Feature changes often touch multiple folders
- **Merge Conflicts**: Multiple teams may edit the same folders frequently
- **Tight Coupling**: Can lead to implicit dependencies between layers
- **Context Switching**: Developers jump between folders for single feature work
- **Scalability Challenges**: Folders become crowded as app grows

### Best For
- Teams organized by technical specialization (UI developers, API developers)
- Smaller to medium teams (5-15 developers)
- Projects with strong technical leadership coordinating across layers
- Applications with highly reusable component libraries

### React 19 Considerations
- Centralized `services/` layer works well with React 19 Server Actions
- `hooks/` folder can house all `use` hook implementations
- Clear separation enables better optimization of Client vs Server Components

---

## Option 3: Atomic Design + Module Structure (Hybrid)
### Philosophy
Combine atomic design principles for UI components with module-based organization for business logic. Emphasizes component reusability and design system thinking.

### Structure
```
src/
├── components/
│   ├── atoms/
│   │   ├── Button/
│   │   │   ├── Button.tsx
│   │   │   ├── Button.test.tsx
│   │   │   ├── Button.stories.tsx
│   │   │   ├── Button.module.css
│   │   │   └── index.ts
│   │   ├── Input/
│   │   ├── Label/
│   │   ├── Icon/
│   │   ├── Badge/
│   │   ├── Avatar/
│   │   └── Spinner/
│   │
│   ├── molecules/
│   │   ├── FormField/
│   │   ├── SearchBar/
│   │   ├── Dropdown/
│   │   ├── Pagination/
│   │   ├── Toast/
│   │   └── Tooltip/
│   │
│   ├── organisms/
│   │   ├── Header/
│   │   ├── Footer/
│   │   ├── Sidebar/
│   │   ├── DataTable/
│   │   ├── UserCard/
│   │   └── NavigationMenu/
│   │
│   └── templates/
│       ├── MainLayout/
│       ├── AuthLayout/
│       ├── DashboardLayout/
│       └── SettingsLayout/
│
├── modules/
│   ├── auth/
│   │   ├── pages/
│   │   │   ├── LoginPage.tsx
│   │   │   └── RegisterPage.tsx
│   │   ├── components/
│   │   │   ├── LoginForm.tsx
│   │   │   └── SocialAuthButtons.tsx
│   │   ├── hooks/
│   │   │   └── useAuth.ts
│   │   ├── services/
│   │   │   └── authService.ts
│   │   ├── types/
│   │   │   └── auth.types.ts
│   │   └── index.ts
│   │
│   ├── dashboard/
│   │   ├── pages/
│   │   ├── components/
│   │   ├── hooks/
│   │   └── index.ts
│   │
│   ├── profile/
│   │   ├── pages/
│   │   ├── components/
│   │   ├── hooks/
│   │   └── index.ts
│   │
│   └── settings/
│       ├── pages/
│       ├── components/
│       └── index.ts
│
├── design-system/
│   ├── tokens/
│   │   ├── colors.ts
│   │   ├── typography.ts
│   │   ├── spacing.ts
│   │   └── breakpoints.ts
│   ├── theme/
│   │   ├── lightTheme.ts
│   │   └── darkTheme.ts
│   └── styles/
│       ├── reset.css
│       └── globals.css
│
├── hooks/
│   ├── useDebounce.ts
│   ├── useLocalStorage.ts
│   ├── useMediaQuery.ts
│   ├── useIntersectionObserver.ts
│   └── index.ts
│
├── services/
│   ├── api/
│   │   ├── client.ts
│   │   ├── endpoints.ts
│   │   └── interceptors.ts
│   ├── storage/
│   │   └── storageService.ts
│   └── analytics/
│       └── analyticsService.ts
│
├── store/
│   ├── slices/
│   ├── middleware/
│   └── index.ts
│
├── utils/
│   ├── formatters.ts
│   ├── validators.ts
│   ├── helpers.ts
│   └── index.ts
│
├── types/
│   ├── common.types.ts
│   ├── api.types.ts
│   └── index.ts
│
├── router/
│   ├── AppRouter.tsx
│   └── routes.config.ts
│
├── assets/
│   ├── images/
│   ├── icons/
│   └── fonts/
│
├── App.tsx
└── main.tsx
```

### Advantages
- **Design System First**: Encourages building robust, reusable component library
- **Clear Component Hierarchy**: Atomic structure makes complexity manageable
- **Storybook-Friendly**: Perfect for component documentation and visual testing
- **Module Flexibility**: Business logic organized independently from UI components
- **Designer-Developer Alignment**: Designers and developers speak same language
- **Progressive Complexity**: Simple atoms build into complex organisms naturally

### Disadvantages
- **Learning Curve**: Team needs to understand atomic design principles
- **Classification Debates**: Deciding if something is molecule vs organism can be subjective
- **Initial Overhead**: More upfront planning for component hierarchy
- **Potential Over-Engineering**: May be overkill for simpler applications

### Best For
- Teams building design systems or component libraries
- Organizations with dedicated design teams
- Products requiring high UI consistency across features
- Teams using Storybook or similar component documentation tools
- Applications that will be white-labeled or themed

### React 19 Considerations
- Atoms and molecules are perfect candidates for Server Components
- Use React 19's `use` hook in organism-level components for data
- Templates can implement Suspense boundaries effectively
- Module pages can leverage Actions for forms and mutations

---

## Decision Matrix

| Criteria | Feature-Based | Layer-Based | Atomic + Module |
|----------|---------------|-------------|-----------------|
| **Team Size** | Large (15+) | Small-Medium (5-15) | Medium-Large (10-20) |
| **Parallel Development** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ |
| **Component Reusability** | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **Onboarding Speed** | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |
| **Design System Focus** | ⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **Feature Isolation** | ⭐⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐ |
| **Refactoring Ease** | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ |
| **Merge Conflict Risk** | ⭐⭐⭐⭐⭐ (Low) | ⭐⭐⭐ (Medium) | ⭐⭐⭐⭐ (Low) |

---

## Cross-Cutting Concerns

### Authentication Layer Integration

**Recommended Structure (All Approaches):**
```
src/
├── core/
│   └── auth/
│       ├── AuthProvider.tsx           # React Context for auth state
│       ├── authService.ts             # Authentication logic
│       ├── authStorage.ts             # Token/session persistence
│       ├── AuthGuard.tsx              # Route protection component
│       ├── PermissionGate.tsx         # Permission-based rendering
│       └── types/
│           └── auth.types.ts
```

**Key Principles:**
- **Single Source of Truth**: Centralize auth state in one provider
- **Token Management**: Abstract token storage and refresh logic
- **Type Safety**: Define strict types for user, permissions, roles
- **HOC Pattern**: Create withAuth() wrapper for protected components
- **Hook Access**: Provide useAuth() hook for components needing auth context

**Implementation Pattern:**
```typescript
// AuthProvider.tsx
export const AuthProvider = ({ children }: { children: ReactNode }) => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  
  // Initialize auth state on mount
  useEffect(() => {
    authService.initializeAuth().then(setUser).finally(() => setLoading(false));
  }, []);
  
  return (
    <AuthContext.Provider value={{ user, loading, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
};

// Usage in routes
<AuthGuard requiredPermissions={['admin']}>
  <AdminDashboard />
</AuthGuard>
```

**React 19 Considerations:**
- Use Server Actions for login/logout mutations
- Leverage Server Components for initial auth state
- Consider using React's new `use` hook for auth context

---

### Logging Infrastructure

**Recommended Structure:**
```
src/
├── core/
│   └── logging/
│       ├── logger.ts                  # Main logger interface
│       ├── loggerService.ts           # Implementation (Winston, Pino, etc.)
│       ├── logLevels.ts               # Log level configuration
│       ├── formatters.ts              # Log formatting utilities
│       └── transports/
│           ├── consoleTransport.ts    # Development logging
│           ├── sentryTransport.ts     # Error tracking
│           └── cloudTransport.ts      # Cloud logging (CloudWatch, etc.)
```

**Key Principles:**
- **Environment Aware**: Different behavior for dev/staging/production
- **Structured Logging**: Use consistent log format with context
- **Log Levels**: DEBUG, INFO, WARN, ERROR, FATAL
- **Performance Impact**: Minimize overhead in production
- **Privacy Compliance**: Sanitize sensitive data (PII, tokens)

**Implementation Pattern:**
```typescript
// logger.ts
export const logger = {
  debug: (message: string, meta?: LogMeta) => loggerService.log('debug', message, meta),
  info: (message: string, meta?: LogMeta) => loggerService.log('info', message, meta),
  warn: (message: string, meta?: LogMeta) => loggerService.log('warn', message, meta),
  error: (message: string, error?: Error, meta?: LogMeta) => {
    loggerService.log('error', message, { ...meta, error: serializeError(error) });
  },
};

// Usage
logger.info('User logged in', { userId: user.id, timestamp: Date.now() });
logger.error('API call failed', error, { endpoint: '/api/users', method: 'GET' });
```

**Best Practices:**
- Log at component boundaries (page loads, API calls, state changes)
- Include correlation IDs for tracing requests
- Avoid logging in render paths (performance)
- Use error boundaries to catch and log React errors

---

### Feature Flagging System

**Recommended Structure:**
```
src/
├── core/
│   └── feature-flags/
│       ├── FeatureFlagProvider.tsx    # Context provider
│       ├── featureFlagService.ts      # Service layer (LaunchDarkly, etc.)
│       ├── FeatureFlag.tsx            # Conditional rendering component
│       ├── useFeatureFlag.ts          # Hook for flag access
│       ├── flags.config.ts            # Flag definitions and types
│       └── types/
│           └── featureFlag.types.ts
```

**Key Principles:**
- **Type-Safe Flags**: Define all flags in a central enum/const
- **Default Values**: Always provide fallbacks for missing flags
- **User Context**: Support user-based targeting (A/B testing)
- **Real-Time Updates**: Listen for flag changes without refresh
- **Developer Experience**: Make flags easy to add/remove

**Implementation Pattern:**
```typescript
// flags.config.ts
export const FeatureFlags = {
  NEW_DASHBOARD: 'new_dashboard',
  ADVANCED_ANALYTICS: 'advanced_analytics',
  BETA_EDITOR: 'beta_editor',
} as const;

export type FeatureFlag = typeof FeatureFlags[keyof typeof FeatureFlags];

// FeatureFlag.tsx (Declarative usage)
<FeatureFlag flag="new_dashboard" fallback={<OldDashboard />}>
  <NewDashboard />
</FeatureFlag>

// useFeatureFlag.ts (Programmatic usage)
const isNewDashboardEnabled = useFeatureFlag('new_dashboard');

if (isNewDashboardEnabled) {
  // Show new feature
}
```

**Advanced Patterns:**
- **Gradual Rollouts**: Percentage-based feature releases
- **Variant Testing**: Return multiple variants for A/B testing
- **Kill Switches**: Emergency feature disabling
- **Local Overrides**: Developer flag overrides for testing

---

### Analytics Integration Patterns

**Recommended Structure:**
```
src/
├── core/
│   └── analytics/
│       ├── AnalyticsProvider.tsx      # Context wrapper
│       ├── analyticsService.ts        # Service abstraction
│       ├── events/
│       │   ├── pageViewEvents.ts      # Page tracking
│       │   ├── userEvents.ts          # User actions
│       │   └── conversionEvents.ts    # Business goals
│       ├── hooks/
│       │   ├── usePageTracking.ts     # Automatic page views
│       │   └── useEventTracking.ts    # Event tracking hook
│       ├── adapters/
│       │   ├── googleAnalytics.ts     # GA4 adapter
│       │   ├── segment.ts             # Segment adapter
│       │   └── mixpanel.ts            # Mixpanel adapter
│       └── types/
│           └── analytics.types.ts
```

**Key Principles:**
- **Vendor Agnostic**: Abstract analytics providers behind interface
- **Privacy First**: Respect user consent (GDPR, CCPA)
- **Type Safety**: Strongly type all events and properties
- **Automatic Tracking**: Page views, errors, performance metrics
- **Manual Tracking**: Business-specific events

**Implementation Pattern:**
```typescript
// analyticsService.ts
export const analytics = {
  page: (pageName: string, properties?: PageProperties) => {
    adapters.forEach(adapter => adapter.page(pageName, properties));
  },
  
  track: (eventName: string, properties?: EventProperties) => {
    adapters.forEach(adapter => adapter.track(eventName, properties));
  },
  
  identify: (userId: string, traits?: UserTraits) => {
    adapters.forEach(adapter => adapter.identify(userId, traits));
  },
};

// usePageTracking.ts (Automatic tracking)
export const usePageTracking = () => {
  const location = useLocation();
  
  useEffect(() => {
    analytics.page(location.pathname, {
      title: document.title,
      url: window.location.href,
    });
  }, [location.pathname]);
};

// Manual tracking
<button onClick={() => {
  analytics.track('button_clicked', {
    buttonName: 'subscribe',
    location: 'pricing_page',
  });
}}>
  Subscribe
</button>
```

**Event Naming Convention:**
```typescript
// Use object_action pattern
'user_signed_up'
'product_viewed'
'cart_item_added'
'payment_completed'
'document_downloaded'
```

---

### Error Tracking Setup

**Recommended Structure:**
```
src/
├── core/
│   └── error-tracking/
│       ├── ErrorBoundary.tsx          # React error boundary
│       ├── errorService.ts            # Error reporting service
│       ├── ErrorFallback.tsx          # Fallback UI component
│       ├── errorNormalizer.ts         # Error standardization
│       ├── adapters/
│       │   ├── sentry.ts              # Sentry integration
│       │   ├── rollbar.ts             # Rollbar integration
│       │   └── bugsnag.ts             # Bugsnag integration
│       └── types/
│           └── error.types.ts
```

**Key Principles:**
- **Graceful Degradation**: Never crash the entire app
- **User Feedback**: Show helpful error messages
- **Contextual Information**: Capture app state, user actions, breadcrumbs
- **Source Maps**: Upload source maps for readable stack traces
- **Error Deduplication**: Group similar errors together

**Implementation Pattern:**
```typescript
// ErrorBoundary.tsx
export class ErrorBoundary extends Component<Props, State> {
  static getDerivedStateFromError(error: Error) {
    return { hasError: true, error };
  }
  
  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    errorService.captureException(error, {
      context: 'ErrorBoundary',
      componentStack: errorInfo.componentStack,
      userAction: 'component_render',
    });
  }
  
  render() {
    if (this.state.hasError) {
      return <ErrorFallback error={this.state.error} reset={this.reset} />;
    }
    return this.props.children;
  }
}

// errorService.ts
export const errorService = {
  captureException: (error: Error, context?: ErrorContext) => {
    // Add breadcrumbs, user context, custom tags
    const normalizedError = normalizeError(error);
    adapters.forEach(adapter => adapter.captureException(normalizedError, context));
  },
  
  captureMessage: (message: string, level: 'info' | 'warning' | 'error') => {
    adapters.forEach(adapter => adapter.captureMessage(message, level));
  },
};

// Usage in async operations
try {
  await fetchUserData();
} catch (error) {
  errorService.captureException(error, {
    context: 'UserDataFetch',
    userId: currentUser.id,
    endpoint: '/api/users',
  });
  // Handle gracefully
}
```

**Error Boundary Strategy:**
```typescript
// App-level boundary (last resort)
<ErrorBoundary fallback={<AppCrashFallback />}>
  <App />
</ErrorBoundary>

// Feature-level boundaries (better UX)
<ErrorBoundary fallback={<DashboardError />}>
  <Dashboard />
</ErrorBoundary>

// Component-level boundaries (most granular)
<ErrorBoundary fallback={<ChartError />}>
  <AnalyticsChart />
</ErrorBoundary>
```

**React 19 Specific:**
- Use Error Boundaries around Server Component boundaries
- Handle Action errors with try/catch and user feedback
- Consider `useFormStatus` for form submission errors

---

## Asset Management

### Static Asset Organization

**Recommended Structure:**
```
public/
├── favicon.ico
├── robots.txt
├── sitemap.xml
└── static/
    ├── images/
    │   ├── brand/
    │   │   ├── logo.svg
    │   │   └── logo-dark.svg
    │   ├── illustrations/
    │   ├── backgrounds/
    │   └── placeholders/
    └── fonts/
        ├── Inter/
        └── Roboto/

src/
├── assets/
│   ├── icons/
│   │   ├── social/
│   │   │   ├── facebook.svg
│   │   │   └── twitter.svg
│   │   ├── ui/
│   │   │   ├── arrow-right.svg
│   │   │   └── close.svg
│   │   └── index.ts              # Barrel export
│   │
│   ├── images/
│   │   ├── avatars/
│   │   ├── products/
│   │   └── marketing/
│   │
│   └── animations/
│       └── lottie/
│           └── loading.json
```

**Decision Tree: public/ vs src/assets/**

Use `public/` for:
- Assets that need specific public URLs (favicon, robots.txt)
- Assets referenced in HTML meta tags
- Large static files that don't need bundling
- Files that should bypass build process
- Assets for third-party integrations

Use `src/assets/` for:
- Assets that benefit from bundling (tree-shaking, optimization)
- Assets used in components via imports
- Assets that need cache busting via content hashes
- Icons and small images for better optimization
- Development-time assets

---

### SVG Handling Strategies

**Three Approaches:**

**1. Inline SVG Components (Best for Icons)**
```typescript
// src/assets/icons/ArrowIcon.tsx
export const ArrowIcon = ({ className, size = 24 }: IconProps) => (
  <svg width={size} height={size} viewBox="0 0 24 24" className={className}>
    <path d="M5 12h14M12 5l7 7-7 7" />
  </svg>
);

// Usage
<ArrowIcon size={32} className="text-blue-500" />
```

**Advantages**: Full CSS control, tree-shakeable, TypeScript props
**Use for**: UI icons, logos, small graphics

**2. SVG as Image Import (Best for Illustrations)**
```typescript
// Component
import heroIllustration from '@/assets/images/hero.svg';

<img src={heroIllustration} alt="Hero illustration" />
```

**Advantages**: Automatic optimization, caching, lazy loading
**Use for**: Large illustrations, complex graphics, backgrounds

**3. SVG Sprite System (Best for Icon Sets)**
```typescript
// src/components/Icon/Icon.tsx
export const Icon = ({ name, size = 24 }: IconProps) => (
  <svg width={size} height={size}>
    <use href={`/sprite.svg#${name}`} />
  </svg>
);

// Usage
<Icon name="arrow-right" size={32} />
```

**Advantages**: Single HTTP request, browser caching, smaller bundle
**Use for**: Large icon sets, repeated icons

**Tooling Recommendations:**
- **SVGR**: Convert SVG to React components automatically
- **SVGO**: Optimize SVG files during build
- **svg-sprite-generator**: Generate sprite sheets

---

### Public vs Source Assets Strategy

**Public Assets (`public/`):**
```
public/
├── favicon.ico                    # Browser tab icon
├── apple-touch-icon.png          # iOS home screen
├── manifest.json                 # PWA manifest
├── robots.txt                    # SEO directives
├── sitemap.xml                   # SEO sitemap
├── _redirects                    # Server redirects
└── static/
    ├── legal/
    │   └── terms.pdf             # Legal documents
    └── downloads/
        └── whitepaper.pdf        # User downloads
```

**Best Practices:**
- Use absolute URLs: `/static/images/logo.png`
- Never change filenames (breaks external references)
- Manually version if needed: `logo-v2.png`
- Keep files under 5MB for performance

**Source Assets (`src/assets/`):**
```
src/assets/
├── images/
│   ├── hero.webp                 # Component images
│   └── product-{id}.png          # Dynamic images
├── icons/
│   └── *.svg                     # Icon components
└── styles/
    └── fonts/                    # Custom web fonts
```

**Best Practices:**
- Import in components: `import logo from '@/assets/images/logo.png'`
- Automatic cache busting via content hashes
- Tree-shaking removes unused assets
- Webpack/Vite optimizes automatically

---

### Component-Level Asset Loading (React 19+)

**Preloading Critical Assets:**
```typescript
// React 19's preload/preinit APIs
import { preload, preinit } from 'react-dom';

export function ProductPage() {
  // Preload images before they're needed
  preload('/images/product-hero.webp', { as: 'image' });
  
  // Preinit stylesheets or scripts
  preinit('/styles/product.css', { as: 'style' });
  
  return <div>...</div>;
}
```

**Lazy Loading Images:**
```typescript
// Modern native lazy loading
<img 
  src="/images/product.webp" 
  loading="lazy"           // Native lazy loading
  decoding="async"         // Async decode
  fetchpriority="low"      // Lower priority for below-fold
  alt="Product image"
/>

// With fallback for critical images
<img 
  src="/images/hero.webp"
  loading="eager"          // Load immediately
  fetchpriority="high"     // Prioritize loading
  alt="Hero image"
/>
```

**Progressive Image Loading:**
```typescript
// Component with LQIP (Low Quality Image Placeholder)
const OptimizedImage = ({ src, alt, lqip }: ImageProps) => {
  const [loaded, setLoaded] = useState(false);
  
  return (
    <div className="relative">
      {/* Blurred placeholder */}
      <img 
        src={lqip} 
        alt="" 
        className={`absolute inset-0 transition-opacity ${loaded ? 'opacity-0' : 'opacity-100'}`}
        aria-hidden="true"
      />
      {/* Full quality image */}
      <img 
        src={src} 
        alt={alt}
        onLoad={() => setLoaded(true)}
        className="relative z-10"
      />
    </div>
  );
};
```

**Image Optimization Best Practices:**
- Use WebP/AVIF with fallbacks for older browsers
- Implement responsive images with `srcset` and `sizes`
- Leverage CDN for image transformations
- Consider using image optimization services (Cloudinary, Imgix)
- Set explicit width/height to prevent layout shift

---

## Routing Architecture

### Route Definition Patterns

**Centralized Route Configuration:**
```typescript
// src/router/routes.config.ts
export const ROUTES = {
  HOME: '/',
  AUTH: {
    LOGIN: '/login',
    REGISTER: '/register',
    FORGOT_PASSWORD: '/forgot-password',
  },
  DASHBOARD: {
    ROOT: '/dashboard',
    ANALYTICS: '/dashboard/analytics',
    SETTINGS: '/dashboard/settings',
  },
  USER: {
    PROFILE: '/user/:id',
    EDIT: '/user/:id/edit',
  },
  ADMIN: {
    ROOT: '/admin',
    USERS: '/admin/users',
    REPORTS: '/admin/reports',
  },
} as const;

// Type-safe route generator
export const generatePath = (path: string, params: Record<string, string>) => {
  return Object.entries(params).reduce(
    (acc, [key, value]) => acc.replace(`:${key}`, value),
    path
  );
};

// Usage
navigate(generatePath(ROUTES.USER.PROFILE, { id: userId }));
```

**Route Metadata Pattern:**
```typescript
// Enhanced route config with metadata
export interface RouteConfig {
  path: string;
  element: ComponentType;
  meta?: {
    title?: string;
    requiresAuth?: boolean;
    permissions?: string[];
    layout?: 'main' | 'auth' | 'admin';
    breadcrumb?: string;
  };
  children?: RouteConfig[];
}

export const routeConfig: RouteConfig[] = [
  {
    path: ROUTES.DASHBOARD.ROOT,
    element: DashboardLayout,
    meta: {
      requiresAuth: true,
      layout: 'main',
    },
    children: [
      {
        path: ROUTES.DASHBOARD.ANALYTICS,
        element: AnalyticsPage,
        meta: {
          title: 'Analytics',
          permissions: ['view_analytics'],
          breadcrumb: 'Analytics',
        },
      },
    ],
  },
];
```

---

### Route-Folder Structure Alignment

**File-Based Routing (Recommended for Scalability):**
```
src/
├── app/                              # or pages/
│   ├── (auth)/                       # Route group (no URL segment)
│   │   ├── login/
│   │   │   └── page.tsx             # /login
│   │   └── register/
│   │       └── page.tsx             # /register
│   │
│   ├── dashboard/
│   │   ├── layout.tsx               # Shared layout
│   │   ├── page.tsx                 # /dashboard
│   │   ├── analytics/
│   │   │   └── page.tsx             # /dashboard/analytics
│   │   └── settings/
│   │       └── page.tsx             # /dashboard/settings
│   │
│   ├── user/
│   │   └── [id]/                    # Dynamic segment
│   │       ├── page.tsx             # /user/:id
│   │       └── edit/
│   │           └── page.tsx         # /user/:id/edit
│   │
│   └── layout.tsx                   # Root layout
```

**Key Conventions:**
- `page.tsx` = Route component
- `layout.tsx` = Shared layout for nested routes
- `loading.tsx` = Loading state (Suspense fallback)
- `error.tsx` = Error boundary for route segment
- `[param]` = Dynamic route parameter
- `(group)` = Route group without URL segment
- `_component.tsx` = Private component (not a route)

**Configuration-Based Routing (Traditional):**
```typescript
// src/router/AppRouter.tsx
export const AppRouter = () => (
  <BrowserRouter>
    <Routes>
      {/* Public routes */}
      <Route element={<AuthLayout />}>
        <Route path={ROUTES.AUTH.LOGIN} element={<LoginPage />} />
        <Route path={ROUTES.AUTH.REGISTER} element={<RegisterPage />} />
      </Route>
      
      {/* Protected routes */}
      <Route element={<ProtectedRoute />}>
        <Route element={<MainLayout />}>
          <Route path={ROUTES.DASHBOARD.ROOT} element={<DashboardPage />} />
          <Route path={ROUTES.DASHBOARD.ANALYTICS} element={<AnalyticsPage />} />
        </Route>
      </Route>
      
      {/* Admin routes */}
      <Route element={<AdminRoute />}>
        <Route path={ROUTES.ADMIN.ROOT} element={<AdminLayout />}>
          <Route index element={<AdminDashboard />} />
          <Route path={ROUTES.ADMIN.USERS} element={<UsersPage />} />
        </Route>
      </Route>
      
      {/* 404 */}
      <Route path="*" element={<NotFoundPage />} />
    </Routes>
  </BrowserRouter>
);
```

---

### Dynamic Routing Strategies

**Parameter-Based Routes:**
```typescript
// URL: /products/:category/:id
<Route path="/products/:category/:id" element={<ProductDetailPage />} />

// Access params in component
const { category, id } = useParams<{ category: string; id: string }>();
```

**Query Parameters:**
```typescript
// URL: /search?q=laptop&sort=price&filter=electronics
const [searchParams, setSearchParams] = useSearchParams();

const query = searchParams.get('q');
const sort = searchParams.get('sort');
const filters = searchParams.getAll('filter');

// Update query params
setSearchParams({ q: 'laptop', sort: 'price' });
```

**Optional Route Segments:**
```typescript
// Match /docs or /docs/getting-started
<Route path="/docs/:section?" element={<DocsPage />} />

// Match /products or /products/electronics/laptops
<Route path="/products/:category?/:subcategory?" element={<ProductsPage />} />
```

**Catch-All Routes:**
```typescript
// Match /files/documents/report.pdf or /files/a/b/c/d
<Route path="/files/*" element={<FileBrowserPage />} />

// Access the wildcard path
const params = useParams();
const filepath = params['*']; // "documents/report.pdf"
```

---

### Route Guards and Protection

**Authentication Guard:**
```typescript
// src/router/guards/ProtectedRoute.tsx
export const ProtectedRoute = () => {
  const { user, loading } = useAuth();
  const location = useLocation();
  
  if (loading) {
    return <LoadingSpinner />;
  }
  
  if (!user) {
    // Redirect to login, preserve intended destination
    return <Navigate to="/login" state={{ from: location }} replace />;
  }
  
  return <Outlet />;
};

// Usage
<Route element={<ProtectedRoute />}>
  <Route path="/dashboard" element={<Dashboard />} />
</Route>
```

**Permission-Based Guard:**
```typescript
// src/router/guards/PermissionRoute.tsx
interface PermissionRouteProps {
  requiredPermissions: string[];
  fallback?: ReactNode;
}

export const PermissionRoute = ({ 
  requiredPermissions, 
  fallback = <UnauthorizedPage /> 
}: PermissionRouteProps) => {
  const { user } = useAuth();
  
  const hasPermission = requiredPermissions.every(
    permission => user?.permissions.includes(permission)
  );
  
  if (!hasPermission) {
    return <>{fallback}</>;
  }
  
  return <Outlet />;
};

// Usage
<Route element={<PermissionRoute requiredPermissions={['admin', 'edit_users']} />}>
  <Route path="/admin/users" element={<UserManagement />} />
</Route>
```

**Role-Based Guard:**
```typescript
// src/router/guards/RoleRoute.tsx
export const RoleRoute = ({ allowedRoles }: { allowedRoles: UserRole[] }) => {
  const { user } = useAuth();
  
  if (!user || !allowedRoles.includes(user.role)) {
    return <Navigate to="/unauthorized" replace />;
  }
  
  return <Outlet />;
};

// Usage
<Route element={<RoleRoute allowedRoles={['admin', 'moderator']} />}>
  <Route path="/admin/*" element={<AdminPanel />} />
</Route>
```

**Feature Flag Guard:**
```typescript
// src/router/guards/FeatureFlagRoute.tsx
export const FeatureFlagRoute = ({ 
  flag, 
  fallback = <NotFoundPage /> 
}: FeatureFlagRouteProps) => {
  const isEnabled = useFeatureFlag(flag);
  
  if (!isEnabled) {
    return <>{fallback}</>;
  }
  
  return <Outlet />;
};

// Usage
<Route element={<FeatureFlagRoute flag="beta_dashboard" />}>
  <Route path="/dashboard-beta" element={<BetaDashboard />} />
</Route>
```

---

### Code Splitting at Route Level

**Lazy Loading Routes:**
```typescript
// React.lazy for route-based code splitting
const Dashboard = lazy(() => import('@/pages/Dashboard'));
const Analytics = lazy(() => import('@/pages/Analytics'));
const Settings = lazy(() => import('@/pages/Settings'));

// Router with Suspense boundaries
<Routes>
  <Route path="/" element={<HomePage />} /> {/* Not lazy - critical path */}
  
  <Route element={<ProtectedRoute />}>
    <Route 
      path="/dashboard" 
      element={
        <Suspense fallback={<DashboardSkeleton />}>
          <Dashboard />
        </Suspense>
      } 
    />
    
    <Route 
      path="/analytics" 
      element={
        <Suspense fallback={<PageLoader />}>
          <Analytics />
        </Suspense>
      } 
    />
  </Route>
</Routes>
```

**Preloading Routes on Hover:**
```typescript
// Prefetch route component on link hover
const prefetchRoute = (importFn: () => Promise<any>) => {
  importFn();
};

// Usage in navigation
<Link 
  to="/dashboard"
  onMouseEnter={() => prefetchRoute(() => import('@/pages/Dashboard'))}
>
  Dashboard
</Link>
```

**Route-Based Chunk Naming:**
```typescript
// vite.config.ts / webpack.config.js
export default {
  build: {
    rollupOptions: {
      output: {
        manualChunks: (id) => {
          if (id.includes('pages/admin')) return 'admin';
          if (id.includes('pages/dashboard')) return 'dashboard';
          if (id.includes('node_modules')) return 'vendor';
        },
      },
    },
  },
};
```

**Progressive Loading Strategy:**
```
Initial Bundle (Critical Path)
├── Core framework (React, Router)
├── Auth flow (Login, Register)
└── Landing page

Lazy Loaded (On-Demand)
├── Dashboard chunk (5 routes)
├── Admin chunk (10 routes)
├── Analytics chunk (3 routes)
└── Settings chunk (7 routes)
```

**React 19 Route Optimization:**
- Use Server Components for static route layouts
- Implement streaming with Suspense for data-heavy routes
- Leverage Actions for route-level data mutations
- Use `startTransition` for non-urgent navigation

---

## React 19 Specific Recommendations

### Server Components Strategy
Regardless of chosen structure, establish clear conventions:
- Default to Server Components unless interactivity needed
- Use `.client.tsx` or `.server.tsx` suffixes when ambiguous
- Document which folders contain primarily client vs server components

### Actions Location
- **Feature-Based**: Place actions alongside feature code in `actions/` subfolder
- **Layer-Based**: Create top-level `actions/` folder organized by domain
- **Atomic + Module**: Place actions in module-level `actions/` folders

### Suspense Boundaries
- Define where Suspense boundaries exist in your chosen structure
- Typically at page/route level or major organism components
- Document loading states strategy across the team

---

## Implementation Recommendations

### For All Structures
1. **Enforce with ESLint**: Use import rules to prevent violations
2. **Document Decisions**: Create ADRs (Architecture Decision Records)
3. **Provide Examples**: Create reference implementations for each pattern
4. **Code Reviews**: Ensure structure adherence during PR reviews
5. **Monorepo Consideration**: Consider Nx or Turborepo for larger structures

### File Naming Conventions
```typescript
// Component files
ComponentName.tsx
ComponentName.test.tsx
ComponentName.stories.tsx
ComponentName.module.css

// Hook files
useHookName.ts
useHookName.test.ts

// Type files
featureName.types.ts
modelName.types.ts

// Utility files
utilityName.ts
utilityName.test.ts
```

### Index File Strategy
```typescript
// Use barrel exports for cleaner imports
// features/authentication/index.ts
export { LoginForm } from './components/LoginForm';
export { useAuth } from './hooks/useAuth';
export type { AuthUser, LoginCredentials } from './types/auth.types';
```

---

## Next Steps for Team Discussion

1. **Evaluate Current Pain Points**: What challenges does your team face today?
2. **Consider Team Structure**: How is your team organized? By feature? By role?
3. **Project Timeline**: Do you need quick wins or can you invest in long-term structure?
4. **Pilot Program**: Test chosen structure on a new feature before full migration
5. **Migration Path**: If refactoring, plan incremental migration strategy
6. **Tooling Setup**: Configure linters, formatters, and import rules to enforce structure

---

## Recommended Choice by Scenario

**Choose Feature-Based if:**
- Team size > 15 developers
- Using squad/pod model
- Building complex, multi-domain product
- Need maximum parallel development

**Choose Layer-Based if:**
- Team size < 15 developers
- Team organized by specialization
- Simple to moderate complexity product
- Strong technical coordination exists

**Choose Atomic + Module if:**
- Building/maintaining design system
- Design-developer collaboration is key
- Need highly reusable component library
- Planning white-label or multi-theme support

---

*This framework should be reviewed quarterly and adjusted based on team growth and project evolution.*